author: frank-xjh

枚举是基于已有知识来猜测答案的一种问题求解策略。

!!! 例题
    求小于 N 的最大素数

找不到合适的一个数学公式来直接计算答案，不妨依次尝试一个数是否是答案。

如果我们从大到小枚举小于 $N$ 的数，那么原问题转化为如何判断一个数是不是素数。

注意到素数的性质要求不能被 $1$ 和它本身之外的数整除，可以直接用于判断。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

## 给出解空间

建立简洁的数学模型。

枚举的时候要想清楚可能的情况是什么，要枚举哪些要素？

## 减少枚举的空间

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

!!! 例题
    一个数组中的数互不相同，求其中和为 $0$ 的数对的个数

枚举两个数的代码很容易就可以写出来。

```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < n; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

我们来看看枚举的范围如何优化。原问题的答案由两部分构成，两个数相等的情况和不相等的情况。相等的情况只需要枚举每一个数判断一下是否合法。至于不相等的情况，由于题中没要求数对是有序的，答案就是有序的情况的两倍（考虑如果 `(a, b)` 是答案，那么 `(b, a)` 也是答案）。我们对于这种情况只需统计人为要求有顺序之后的答案，最后再乘上 $2$ 就好了。

我们不妨要求第一个数要出现在靠前的位置。代码如下：

```cpp
for (int i = 0; i < n; ++i)
  for (int j = 0; j < i; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

不难发现这里已经减少了 $j$ 的枚举范围，减少了这段代码的时间开销。

然而这并不是最优的结果。

两个数是否都一定要枚举出来呢？这里我们发现枚举其中一个数之后，题目的条件已经帮我们确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。

```cpp
// 要求 a 数组中的数的绝对值都小于 MAXN
bool met[MAXN * 2];
// 初始化 met 数组为 0；
memset(met, 0, sizeof(met));
for (int i = 0; i < n; ++i) {
  if (met[MAXN - a[i]]) ++ans;
  // 为了避免负数下标
  met[a[i] + MAXN] = 1;
}
```

## 选择合适的枚举顺序

比如第一个例题中要求的是最大的符合条件的素数。自然是从大到小枚举比较合适。
